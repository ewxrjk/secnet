#!/usr/bin/perl -w
#
# subdirmk - &-filter (makefile generation program)
#  Copyright 2019 Ian Jackson
# SPDX-License-Identifier: LGPL-2.0-or-later
#
# $(srcdir)/subdirmk/generate [--srcdir=SRCDIR] [--] SUBDIR...
#
# generates in each subdirectory	from in each subdirectory
#     Subdir.mk.tmp			    Subdir.sd.mk
#     Makefile
# and in toplevel			and in toplevel
#     main.mk.tmp			    Perdir.sd.mk

use strict;
use POSIX;

print "$0 @ARGV\n" or die $!;

our $srcdir='.';

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_ = shift @ARGV;
    last if $_ eq '--';
    if (s/^--srcdir=//) {
	$srcdir=$';
    } else {
	die "$0: unknown option \`$_'\n";
    }
}
our @subdirs = @ARGV;

s{/+$}{} foreach @subdirs;

our $root = [ '.', [ ] ];
# each node is [ 'relative subdir name', \@children ]

sub build_tree () {
    foreach my $subdir (@subdirs) {
	my @path = $subdir eq '.' ? () : split m{/+}, $subdir;
	my $node = $root;
	foreach my $d (@path) {
	    my ($c,) = grep { $_->[0] eq $d } @{ $node->[1] };
	    if (!$c) {
		$c = [ $d, [ ] ];
		push @{ $node->[1] }, $c;
	    }
	    $node = $c;
	}
    }
}

sub target_varname ($$) {
    my ($var_prefix, $target) = @_;
    return $var_prefix.'TARGETS'.($target eq 'all' ? '' : "_$target");
}

our $writing_output;
our $buffering_output;
our %output_files;
our %input_files;

sub close_any_output_file() {
    return unless defined $writing_output;
    O->error and die "error writing $writing_output.tmp: $! (?)\n";
    close O or die "error closing $writing_output.tmp: $!\n";
    $writing_output = undef;
}

sub o {
    if (defined $buffering_output) {
	$buffering_output .= $_ foreach @_;
	return;
    }
    die unless defined $writing_output;
    print O @_ or die "error writing $writing_output.tmp: $!\n";
}

sub start_output_file ($) {
    close_any_output_file();
    ($writing_output) = @_;
    die "$writing_output ?" if $output_files{$writing_output}++;
    my $tmp = "$writing_output.tmp";
    open O, ">", $tmp or die "create $tmp: $!\n";
    o "# autogenerated - do not edit\n";
}

sub install_output_files () {
    close_any_output_file();
    foreach my $f (sort keys %output_files) {
	rename "$f.tmp", $f or die "install new $f: $!\n";
    }
}

sub write_makefile ($$) {
    my ($dir_prefix,$depth) = @_;
    #print STDERR "write_makefile @_\n";
    start_output_file("${dir_prefix}Makefile");
    my $cd = $depth ? join('/', ('..',) x $depth) : '.';
    o <<END;
default: all
%:	FORCE-ALWAYS-RUN
	\@:
Makefile FORCE-ALWAYS-RUN:
	\$(MAKE) -C $cd -f main.mk \$(addprefix ${dir_prefix},\$(MAKECMDGOALS))
.SUFFIXES:
END
}

sub process_input_mk ($$$$$$$$);
sub process_input_mk ($$$$$$$$) {
    my ($dir_prefix, $dir_suffix, $dir_name,
	$var_prefix, $targets,
	$f, $esclitr, $enoent_ok) = @_;

    my $caps_re = qr{[A-Z]};
    my $lc_re = qr{[a-z]};

    my $esc;
    my $set_esc = sub {
	$esc = $$esclitr;
	$esc =~ s/\W/\\$&/g;
    };
    $set_esc->();

    my $input = new IO::File $f, '<';
    if (!$input) {
	die "open $f: $!\n" unless $!==ENOENT && $enoent_ok;
	return;
    }
    $input_files{$f}++;

    while (<$input>) {
	if (s#^\s*$esc\:##) {
	    $buffering_output='';
	}
	for (;;) {
	    unless (s{^(.*?)(\\)?(?=$esc)}{}) { o $_; last; }
	    o $1;
	    if ($2) { o $$esclitr; next; }
	    s{^$esc}{} or die "$_ ?";
	    if (s{^$esc}{}) { o "$$esclitr$$esclitr" }
	    elsif (s{^TARGETS(?:_([0-9a-zA-Z_]+))?(?=\W)}{}) {
		my $t = $1 // 'all';
		o target_varname($var_prefix, $t);
		$targets->{$t} //= [ ];
	    }
	    elsif (m{^(?=$caps_re)}) { o $var_prefix }
	    elsif (m{^(?=$lc_re)}) { o $dir_prefix }
	    elsif (s{^_}{}) { o $var_prefix }
	    elsif (s{^/}{}) { o $dir_prefix }
	    elsif (s{^=_}{}) { o $var_prefix }
	    elsif (s{^=/}{}) { o $dir_name }
	    elsif (s{^\^}{}) { o "\$(top_srcdir)${dir_suffix}" }
	    elsif (s{^\}}{}) { o "\$(abs_top_srcdir)${dir_suffix}" }
	    elsif (s{^(?:[ \t]+([~^]))?(?=[ \t])}{}) {
		my $prefix =
		    !$1       ? $dir_prefix                     :
		    $1 eq '~' ? '$(abs_top_srcdir)'.$dir_suffix :
		    $1 eq '~' ? '$(abs_top_srcdir)'.$dir_suffix :
		    die;
		my $after='';
		if (m{([ \t])$esc}) { ($_,$after) = ($`, $1.$'); }
		s{(?<=[ \t])(?=\S)(?!\\\s*$)}{$prefix}g;
		o $_;
		$_ = $after;
	    } elsif (s{^![ \t]+}{}) {
		o $_;
		$_ = '';
	    } elsif (s{^!(\S+)(?:[ \t]+|$)}{}) {
		$$esclitr = $1;
		$set_esc->();
	    } else {
		die "bad escape $$esclitr$_ ";
	    }
	}
	if (defined $buffering_output) {
	    $_=$buffering_output;
	    $buffering_output=undef;
	    if (m#^(-?)include\s+(\S+)\s+$#) {
		my $subf = "$srcdir/$2";
		process_input_mk($dir_prefix, $dir_suffix, $dir_name,
				 $var_prefix, $targets,
				 $subf, $esclitr, $1);
		o "\n";
	    } else {
		die "unknown directive $_ ";
	    }
	}
    }
    $input->error and die "read $f: $!\n";
    close $input or die "close $f: $!\n";
}

sub filter_subdir_mk ($$$$$) {
    my ($dir_prefix, $dir_suffix, $dir_name,
	$var_prefix, $targets) = @_;

    #use Data::Dumper;
    #print STDERR "filter @_\n";

    my $esclit = '&';

    my $pi = sub {
	my ($f, $enoentok) = @_;
	process_input_mk($dir_prefix, $dir_suffix, $dir_name,
			 $var_prefix, $targets,
			 "${srcdir}/$f", \$esclit, $enoentok);
    };
    $pi->("${dir_prefix}Subdir.sd.mk", 0);
    $pi->("Perdir.sd.mk",              1);
}

sub process_subtree ($$);
sub process_subtree ($$) {
    # => list of descendants (in form SUBDIR/)
    # recursive, children first
    my ($node, $path) = @_;

    #use Data::Dumper;
    #print STDERR Dumper(\@_);

    my $dir_prefix = join '', map { "$_/" } @$path;
    my $dir_suffix = join '', map { "/$_" } @$path;
    my $dir_name = join '/', @$path ? @$path : '.';
    my $var_prefix = join '', map { "${_}_" } @$path ? @$path : qw(TOP);

    write_makefile($dir_prefix, scalar @$path);

    my %targets = (all => []);
    foreach my $child (@{ $node->[1] }) {
	my @childpath = (@$path, $child->[0]);
	my $child_subdir = join '/', @childpath;
	mkdir $child_subdir or $!==EEXIST or die "mkdir $child_subdir: $!";
	push @{ $targets{$_} }, $child_subdir foreach
	    process_subtree($child, \@childpath);
    }
    start_output_file("${dir_prefix}Subdir.mk.tmp");

    filter_subdir_mk($dir_prefix, $dir_suffix, $dir_name,
		     $var_prefix, \%targets);

    o "\n";

    my @targets = sort keys %targets;
    foreach my $target (@targets) {
	my $target_varname = target_varname($var_prefix, $target);
	print O "${dir_prefix}${target}:: \$($target_varname)";
	foreach my $child_subdir (@{ $targets{$target} }) {
	    print O " $child_subdir/$target";
	}
	print O "\n";
    }
    
    return @targets;
}

sub process_tree() {
    process_subtree($root, [ ]);
    start_output_file("main.mk.tmp");
    foreach my $v (qw(top_srcdir abs_top_srcdir)) {
	o "$v=\@$v@\n";
    }
    o "MAKEFILES += Subdir.mk\n";
    foreach my $subdir (@subdirs) {
	o "MAKEFILES += $subdir/Subdir.mk\n";
    }
    foreach my $input (sort keys %input_files) {
	o "MAKEFILE_TEMPLATES += $input\n";
    }
    o "include \$(MAKEFILES)";
}

build_tree();
process_tree();
install_output_files();
