#!/usr/bin/perl -w
#
# $(srcdir)/build-aux/subdirmk-setup SUBDIR...
#
# generates
#   Subdir.mk.tmp
#   Makefile.tmp

use strict;

our $srcdir;
our @subdirs = @ARGV;

die unless $ARGV[0] eq '--srcdir';
die unless @ARGV>=2;
shift @ARGV;
($srcdir, @subdirs) = @ARGV;

our $root = [ '.', [ ] ];
# each node is [ 'relative subdir name', \@children ]

sub build_tree () {
    foreach my $subdir (@subdirs) {
	my @path = $subdir eq '.' ? () : split m{/+}, $subdir;
	my $node = $root;
	foreach my $d (@path) {
	    my ($c,) = grep { $_->[0] eq $d } @{ $node->[1] };
	    if (!$c) {
		$c = [ $d, [ ] ];
		push @{ $node->[1] }, $c;
	    }
	    $node = $c;
	}
    }
}

sub target_varname ($$) {
    my ($var_prefix, $target) = @_;
    return $var_prefix.'TARGETS'.($target eq 'all' ? '' : "_$target");
}

our $writing_output;
our %output_files;

sub close_any_output_file() {
    return unless defined $writing_output;
    O->error and die "error writing $writing_output.tmp: $! (?)\n";
    close O or die "error closing $writing_output.tmp: $!\n";
    $writing_output = undef;
}

sub start_output_file ($) {
    close_any_output_file();
    ($writing_output) = @_;
    die if $output_files{$writing_output}++;
    my $tmp = "$writing_output.tmp";
    open O, ">", $tmp or die "create $tmp: $!\n";
}

sub o {
    die unless defined $writing_output;
    print O @_ or die "error writing $writing_output.tmp: $!\n";
}

sub write_makefile ($$) {
    my ($dir_prefix,$depth) = @_;
    start_output_file("${dir_prefix}Makefile");
    my $cd = $depth ? join('/', ('..',) x $depth) : '.';
    o sprintf <<'END', $cd, $dir_prefix;
default: all
%%:
	$(MAKE) -C %s %s$@
END
}

sub filter_subdir_mk ($$$$$) {
    my ($dir_prefix, $dir_suffix, $dir_name,
	$var_prefix, $targets) = @_;

    my $in = "${srcdir}/${dir_prefix}Subdir.mk.in";
    open I, '<', $in or die "open $in: $!\n";
    my $caps_re = qr{[A-Z][0-9_A-Z]*(?=\W)};
    my $lc_e = qr{[a-z][-+,0-9_a-z]*(?=\W)};
    my $esclit = '&';
    my $esc = '\\&';

    while (<I>) {
	for (;;) {
	    unless (s{^(.*?)(\\)?(?=$esc)}{}) { o $_; last; }
	    o $1;
	    if ($2) { o $esclit; next; }
	    s{^$esc}{} or die "$_ ?";
	    if (s{^$esc}{}) { o "$esclit$esclit" }
	    elsif (m{^TARGETS(?:_[0-9a-zA-Z_]+)?(?=\W)}{}) {
		my $t = $2 // 'all';
		o target_varname($varname_prefix, $t);
		$targets->{$t}=1;
	    }
	    elsif (m{^(?=$caps_re)}) { o "${var_prefix}_" }
	    elsif (m{^(?=$lc_re)}) { o $dir_prefix }
	    elsif (s{^_}{}) { o "${var_prefix}_" }
	    elsif (s{^/}{}) { o $dir_prefix }
	    elsif (s{^=_}{}) { o $var_prefix }
	    elsif (s{^=/}{}) { o $dir_name }
	    elsif (s{^\^}{}) { o "\$(top_srcdir)${dir_suffix}" }
	    elsif (s{^\}}{}) { o "\$(abs_top_srcdir)${dir_suffix}" }
	    elsif (s{^(?:[ \t]+([~^]))?(?=[ \t]){}}{}) {
		my $prefix =
		    !$1       ? $dir_prefix                     :
		    $1 eq '~' ? '$(abs_top_srcdir)'.$dir_suffix :
		    $1 eq '~' ? '$(abs_top_srcdir)'.$dir_suffix :
		    die;
		my $after='';
		if (m{([ \t])$esc}) { ($_,$after) = ($`, $1.$'); }
		s{(?<=[ \t])(?=\S)(?!\\\s*$)}{$prefix}g;
		o $_;
		$_ = $after;
	    } elsif (s{^![ \t]+}{}) {
		o $_;
		$_ = '';
	    } elsif (s{^!(\pPosixWord+|\pPosixPunct+)[ \t]*}{}) {
		$esclit = $1;
		$esc = $esclit;
		$esc =~ s/\W/\\$&/g;
	    } else {
		die "bad escape $esclit$_ ";
	    }
	}
    }
}

sub process_subtree ($$) {
    # => list of descendants (in form SUBDIR/)
    # recursive, children first
    my ($node, $path);

    my $dir_prefix = join '', map { "$_/" } @$path;
    my $dir_suffix = join '', map { "/$_" } @$path;
    my $dir_name = join '/', @$path ? @$path : '.';
    my $var_prefix = map { "${_}_" } @$path ? @$path : qw(TOP);

    write_makefile($subdir, scalar @$path);

    my %targets = qw(all 1);
    my @child_subdirs;
    foreach my $child (@{ $node->[1] }) {
	my @childpath = (@$path, $child->[0]);
	push @child_subdirs, join '/', @childpath;
	$targets{$_}++ foreach
	    process_subtree($child, [  ]);
    }
    start_output_file("$subdir/Subdir.mk.tmp");

    filter_subdir_mk($dir_prefix, $dir_suffix, $dir_name,
		     $var_prefix, \%targets);

    my @targets = sort keys %targets;
    foreach my $target (@targets) {
	my $target_varname = target_varname($var_prefix, target);
	print O <<END;
${dprefix}${target}: \$($target_varname)
END
	if (@child_subdirs) {
	    print O "${dprefix}${target}:";
	    foreach my $child_subdir (@child_subdirs) {
		print O " $child_subdir/$target";
	    }
	    print O "\n";
	}
    }
    
    return @targets;
}

sub process_tree() {
    process_subtree($root, [ ]);
    start_output_file("subdirs.mk");
    o "include Subdir.mk\n";
    foreach my $subdir (@subdirs) {
	o "include $subdir/Subdir.mk";
    }
}

build_tree();
process_tree();
install_output_files();
