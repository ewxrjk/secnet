#!/usr/bin/perl -w
#
# subdirmk - &-filter (makefile generation program)
#  Copyright 2019 Ian Jackson
# SPDX-License-Identifier: LGPL-2.0-or-later
#
# $(srcdir)/subdirmk/generate [--srcdir=SRCDIR] [--] SUBDIR...
#
# generates in each subdirectory
#     Subdir.mk.tmp
#     Makefile
# and in toplevel
#     main.mk.tmp

use strict;
use POSIX;

print "$0 @ARGV\n" or die $!;

our $srcdir='.';

while (@ARGV && $ARGV[0] =~ m/^-/) {
    $_ = shift @ARGV;
    last if $_ eq '--';
    if (s/^--srcdir=//) {
	$srcdir=$';
    } else {
	die "$0: unknown option \`$_'\n";
    }
}
our @subdirs = @ARGV;

s{/+$}{} foreach @subdirs;

our $root = [ '.', [ ], 1 ];
# each node is [ 'relative subdir name', \@children, $mentioned ]

sub build_tree () {
    foreach my $subdir (@subdirs) {
	my @path = $subdir eq '.' ? () : split m{/+}, $subdir;
	my $node = $root;
	foreach my $d (@path) {
	    my ($c,) = grep { $_->[0] eq $d } @{ $node->[1] };
	    if (!$c) {
		$c = [ $d, [ ] ];
		push @{ $node->[1] }, $c;
	    }
	    $node = $c;
	}
	$node->[2] = 1;
    }
}

sub target_varname ($$) {
    my ($var_prefix, $target) = @_;
    return $var_prefix.'TARGETS'.($target eq 'all' ? '' : "_$target");
}

our $writing_output;
our $buffering_output;
our %output_files;
our %input_files;
our @output_makefiles;

sub close_any_output_file() {
    return unless defined $writing_output;
    O->error and die "error writing $writing_output.tmp: $! (?)\n";
    close O or die "error closing $writing_output.tmp: $!\n";
    $writing_output = undef;
}

sub oraw {
    die unless defined $writing_output;
    print O @_ or die "error writing $writing_output.tmp: $!\n";
}

sub oud { # undoubled
    if (defined $buffering_output) {
	$buffering_output .= $_ foreach @_;
	return;
    }
    oraw @_;
}

our $ddbl;

sub od { # maybe $-doubled
    if (!$ddbl) {
	oud @_;
	return;
    }
    foreach (@_) {
	my $e = $_;
	$e =~ s{\$}{\$\$}g;
	oud $e;
    }
}

sub start_output_file ($) {
    close_any_output_file();
    ($writing_output) = @_;
    die "$writing_output ?" if $output_files{$writing_output}++;
    my $tmp = "$writing_output.tmp";
    open O, ">", $tmp or die "create $tmp: $!\n";
    oraw "# autogenerated - do not edit\n";
}

sub install_output_files () {
    close_any_output_file();
    foreach my $f (sort keys %output_files) {
	rename "$f.tmp", $f or die "install new $f: $!\n";
    }
}

sub write_makefile ($$) {
    my ($dir_prefix,$depth) = @_;
    #print STDERR "write_makefile @_\n";
    start_output_file("${dir_prefix}Makefile");
    my $cd = $depth ? join('/', ('..',) x $depth) : '.';
    my $suppress_templates=
	'$(if $(filter-out clean real-clean, $(subdirmk_targets)),,'.
	' MAKEFILE_TEMPLATES=)';
    oraw <<END;
default: all
\$(filter-out all,\$(MAKECMDGOALS)) all: run-main.mk
	\@:
subdirmk_targets:=\$(or \$(MAKECMDGOALS),all)
Makefile run-main.mk:
	\$(MAKE) -C $cd -f main.mk \$(addprefix ${dir_prefix},\$(subdirmk_targets))$suppress_templates
.SUFFIXES:
.PHONY:	run-main.mk
END
}

our ($dir_prefix, $dir_suffix, $dir_name,
     $var_prefix, $var_prefix_name);

sub dir_prefix ($) {
    my ($path) = @_;
    join '', map { "$_/" } @$path;
}

sub set_dir_vars ($) {
    my ($path) = @_;
    $dir_prefix = dir_prefix($path);
    $dir_suffix = join '', map { "/$_" } @$path;
    $dir_name = join '/', @$path ? @$path : '.';
    $var_prefix_name = join '_', @$path ? @$path : qw(TOP);
    $var_prefix = "${var_prefix_name}_";
}

sub process_input_mk ($$$$);
sub process_input_mk ($$$$) {
    my ($targets, $f, $esclitr, $enoent_ok) = @_;

    my $caps_re = qr{[A-Z]};
    my $lc_re = qr{[a-z]};

    my $esc;
    my $set_esc = sub {
	$esc = $$esclitr;
	$esc =~ s/\W/\\$&/g;
    };
    $set_esc->();

    my $input = new IO::File $f, '<';
    if (!$input) {
	die "open $f: $!\n" unless $!==ENOENT && $enoent_ok;
	return;
    }
    $input_files{$f}++;

    my %srcdirmap = (
		  '^' => "\$(top_srcdir)${dir_suffix}",
		  '~' => "\$(top_srcdir)",
		    );
    my %pfxmap = (
		  ''  => $dir_prefix,
		 );
    $pfxmap{$_} = $srcdirmap{$_}.'/' foreach keys %srcdirmap;

    local $ddbl;
    my @nest;

    my $push_nest = sub {
	my ($nk, $nndbl) = @_;
	unshift @nest, [ $nk, $ddbl ];
	$ddbl = $nndbl;
    };
    my $pop_nest = sub {
	my ($nk) = @_;
	die unless $nest[0][0] eq $nk;
	$ddbl = (shift @nest)[1];
    };

    while (<$input>) {
	if (s#^\s*$esc\:changequote\s+(\S+)\s+$##) {
	    $$esclitr = $1;
	    $set_esc->();
	    next;
	} elsif (s#^\s*$esc\:endm\s+$##) {
	    $pop_nest->('Macro');
	    od "endef\n";
	    next;
	} elsif (s#^\s*$esc\:(?=(-?)include|macro)##) {
	    $buffering_output='';
	} elsif (m#^\s*$esc\:([a-z][-0-9a-z_]*)#) {
	    die "unknown directive $1";
	} elsif (s{^\s*${esc}TARGETS(?:_([0-9a-zA-Z_]+))?(?=\W)}{}) {
	    my $t = $1 // 'all';
	    od target_varname($var_prefix, $t);
	    $targets->{$t} //= [ ];
	}
	for (;;) {
	    die if $ddbl && defined $buffering_output;
	    unless (@nest && $nest[0][0] eq 'Eval'
		    ? s{^(.*?)($esc|[{}])}{}
		    : s{^(.*?)($esc)}{}) { od $_; last; }
	    od $1;
	    if ($2 eq '{') {
		$ddbl++;
		next;
	    } elsif ($2 eq '}') {
		next if --$ddbl;
		$pop_nest->('Eval');
		od '}}';
		next;
	    }
	    if (s{^\\$esc}{}) { od "$$esclitr" }
	    elsif (s{^\\\$}{}) { oud '$' }
	    elsif (s{^\\\s+$}{}) { }
	    elsif (s{^$esc}{}) { od "$$esclitr$$esclitr" }
	    elsif (m{^(?=$caps_re)}) { od $var_prefix }
	    elsif (s{^\$([A-Za-z]\w+)}{}) { od "\$(${var_prefix}$1)" }
	    elsif (s{^([~^]?)(?=$lc_re)}{}) { od $pfxmap{$1} }
	    elsif (s{^_}{}) { od $var_prefix }
	    elsif (s{^=}{}) { od $var_prefix_name }
	    elsif (s{^([~^]?)/}{}) { od $pfxmap{$1} }
	    elsif (s{^\.}{}) { od $dir_name }
	    elsif (s{^([~^])\.}{}) { od $srcdirmap{$1} }
	    elsif (s{^\$\-}{}) { $ddbl=undef; }
	    elsif (s{^\$\+}{}) { $ddbl=1; }
	    elsif (s{^\$\(}{}) { die unless $ddbl; oud "\$("; }
	    elsif (s{^\$(\d+)}{}) { die unless $ddbl; oud "\$($1)"; }
	    elsif (s{^\$\{}{}) {
		die if $ddbl;
		od '${eval ${call ';
		$push_nest->('Eval',1);
	    } elsif (s{^([~^]?)(?=[ \t])}{}) {
		my $prefix = $pfxmap{$1} // die;
		my $after='';
		if (m{([ \t])$esc}) { ($_,$after) = ($`, $1.$'); }
		s{(?<=[ \t])(?=\S)(?!\\\s*$)}{$prefix}g;
		od $_;
		$_ = $after;
	    } elsif (s{^\#}{}) {
		$_ = '';
	    } elsif (s{^![ \t]+}{}) {
		od $_;
		$_ = '';
	    } else {
		die "bad escape $$esclitr$_ ";
	    }
	}
	if (defined $buffering_output) {
	    $_=$buffering_output;
	    $buffering_output=undef;
	    if (m#^(-?)include\s+(\S+)\s+$#) {
		my $subf = "$srcdir/$2";
		process_input_mk($targets, $subf, $esclitr, $1);
		od "\n";
	    } elsif (m#^macro\s+(\S+)\s+$#) {
		od "define $1\n";
		$push_nest->('Macro', 1);
	    } else {
		die "internal error buffering directive $_ ";
	    }
	}
    }
    $input->error and die "read $f: $!\n";
    close $input or die "close $f: $!\n";
}

sub filter_subdir_mk ($) {
    my ($targets) = @_;

    #use Data::Dumper;
    #print STDERR "filter @_\n";

    my $esclit = '&';

    my $pi = sub {
	my ($f, $enoentok) = @_;
	process_input_mk($targets, "${srcdir}/$f", \$esclit, $enoentok);
    };
    $pi->("Prefix.sd.mk",              1);
    $pi->("${dir_prefix}Subdir.sd.mk", 0);
    $pi->("Suffix.sd.mk",              1);
}

sub process_subtree ($$);
sub process_subtree ($$) {
    # => list of targets (in form SUBDIR/)
    # recursive, children first
    my ($node, $path) = @_;

    #use Data::Dumper;
    #print STDERR Dumper(\@_);

    my $dir_prefix = dir_prefix($path);
    # ^ this is the only var which we need before we come back from
    #   the recursion.

    push @output_makefiles, "${dir_prefix}Subdir.mk";
    write_makefile($dir_prefix, scalar @$path);

    my %targets = (all => []);
    foreach my $child (@{ $node->[1] }) {
	my @childpath = (@$path, $child->[0]);
	my $child_subdir = join '/', @childpath;
	mkdir $child_subdir or $!==EEXIST or die "mkdir $child_subdir: $!";
	push @{ $targets{$_} }, $child_subdir foreach
	    process_subtree($child, \@childpath);
    }

    set_dir_vars($path);
    start_output_file("${dir_prefix}Subdir.mk.tmp");

    if ($node->[2]) {
	filter_subdir_mk(\%targets);
    } else {
	my $sdmk = "${dir_prefix}Subdir.sd.mk";
	if (stat $sdmk) {
	    die "$sdmk unexpectedly exists (${dir_prefix} not mentioned)";
	} elsif ($!==ENOENT) {
	} else {
	    die "stat $sdmk: $!";
	}
    }

    oraw "\n";

    my @targets = sort keys %targets;
    foreach my $target (@targets) {
	my $target_varname = target_varname($var_prefix, $target);
	print O "${dir_prefix}${target}:: \$($target_varname)";
	foreach my $child_subdir (@{ $targets{$target} }) {
	    print O " $child_subdir/$target";
	}
	print O "\n";
    }
    if (@targets) {
	print O ".PHONY:";
	print O " ${dir_prefix}${_}" foreach @targets;
	print O "\n";
    }

    return @targets;
}

sub process_final ($) {
    my ($otargets) = @_;
    set_dir_vars([]);
    push @output_makefiles, "Final.mk";
    start_output_file("Final.mk.tmp");
    my %ntargets;
    my $esclit='&';
    process_input_mk(\%ntargets, "${srcdir}/Final.sd.mk", \$esclit, 1);
    delete $ntargets{$_} foreach @$otargets;
    my @ntargets = sort keys %ntargets;
    die "late new targets @ntargets" if @ntargets;
}

sub process_tree() {
    my @targets = process_subtree($root, [ ]);
    process_final(\@targets);
    start_output_file("main.mk.tmp");
    foreach my $v (qw(top_srcdir abs_top_srcdir)) {
	oraw "$v=\@$v@\n";
    }
    oraw "SUBDIRMK_MAKEFILES :=\n";
    oraw "MAKEFILE_TEMPLATES :=\n";
    foreach my $mf (@output_makefiles) {
	oraw "SUBDIRMK_MAKEFILES += $mf\n";
    }
    foreach my $input (sort keys %input_files) {
	oraw "MAKEFILE_TEMPLATES += $input\n";
    }
    oraw "include \$(SUBDIRMK_MAKEFILES)\n";
}

build_tree();
process_tree();
install_output_files();
